1)Configure a Jenkins pipeline for continuous deployment to Kubernetes Engine.


gcloud config set compute/zone us-east1-b

git clone https://source.developers.google.com/p/$DEVSHELL_PROJECT_ID/r/sample-app

=====In the GCP Console go to Navigation Menu >Kubernetes Engine > Clusters
=====Then Checkbox check cluster named jenkins-cd.

gcloud container clusters get-credentials jenkins-cd 

kubectl create clusterrolebinding cluster-admin-binding --clusterrole=cluster-admin --user=$(gcloud config get-value account)
 

export POD_NAME=$(kubectl get pods --namespace default -l "app.kubernetes.io/component=jenkins-master" -l "app.kubernetes.io/instance=cd" -o jsonpath="{.items[0].metadata.name}")

kubectl port-forward $POD_NAME 8080:8080 >> /dev/null &

printf $(kubectl get secret cd-jenkins -o jsonpath="{.data.jenkins-admin-password}" | base64 --decode);echo

===notedown password
====open preview port 8080>sign in thr previous password (admin)

cd sample-app

kubectl create ns production

kubectl apply -f k8s/production -n production

kubectl apply -f k8s/canary -n production

kubectl apply -f k8s/services -n production

kubectl get svc

kubectl get service gceme-frontend -n production   (====rerun until u get ext ip)
				

git init

git config credential.helper gcloud.sh

git remote add origin https://source.developers.google.com/p/$DEVSHELL_PROJECT_ID/r/sample-app

git config --global user.email "your@qwiklabs.net"      ===replace your from topright corner

git config --global user.name "[YOUR_USERNAME]"         ===replace name

git add .
git commit -m "initial commit"
git push origin master


====jenkins tab>manage jenkins>manage credential>click on jenkins>click on global credential(unrestricted)>add credential>   name:ggogle ser acc from metadata >ok
====jenkins>new items>sample-app>select multibrach pipeline>ok
=====branch source>add source> credential:select quick....
			       repository: https://source.developers.google.com/p/[PROJECT_ID]/r/sample-app
=====Scan Multibranch Pipeline Triggers, check Periodically if not otherwise run
             Interval: 1 minute

======jenkinstab>save>status>

====>status is failed

open console

git config --global user.name

git config --global user.email

git pull origin

=====>then delete sample-app and create again

git checkout -b new-feature

vi main.go
====new window>main.go>in line 46,change the version number to "2.0.0". 
vi html.go
=====>line 37&81-change blue to orange

git add Jenkinsfile html.go main.go

git commit -m "Version 2.0.0"

git push origin new-feature

====jenk tab>jenkins homepage>click on sample-app>succsess in master









2)

curl http://localhost:8001/api/v1/namespaces/new-feature/services/gceme-frontend:80/proxy/version

=====>if Failed to connect to localhost port 8001: Connection refused error occurs

kubectl proxy &

Starting to serve on 127.0.0.1:8001

====>again type

curl http://localhost:8001/api/v1/namespaces/new-feature/services/gceme-frontend:80/proxy/version

kubectl get service gceme-frontend -n production  
git checkout -b canary
git push origin canary

export FRONTEND_SERVICE_IP=$(kubectl get -o \
jsonpath="{.status.loadBalancer.ingress[0].ip}" --namespace=production services gceme-frontend)

git checkout master

git push origin master

=====jenk tab>jenk homepage>sample-app  (2 file shd be there)

export FRONTEND_SERVICE_IP=$(kubectl get -o \
jsonpath="{.status.loadBalancer.ingress[0].ip}" --namespace=production services gceme-frontend)

while true; do curl http://$FRONTEND_SERVICE_IP/version; sleep 1; done

====== after the you see output 2.0.0 CHECK YOUR #2 PROGRESS (CHECK MAY FAIL OR/AND NEED DELAY, DUNNO WHY) refresh

kubectl get service gceme-frontend -n production

====check your #3, #4(may fail)so run

git merge canary
git push origin master
export FRONTEND_SERVICE_IP=$(kubectl get -o \
jsonpath="{.status.loadBalancer.ingress[0].ip}" --namespace=production services gceme-frontend)

===check #2,#4 rerun abv if not





































2)Push an update to the application to a development branch.



===Create a development branch and push it to the Git server.
git checkout -b new-feature

===Now Open html.go
vi html.go
i

===Change the two instances of <div class="card blue"> with following.
<div class="card orange">
===save and esc

vi main.go
i

===const version string = "1.0.0"
==update it to
const version string = "2.0.0"
===save and esc

git config --global user.email "[EMAIL_ADDRESS]"
git config --global user.name "[USERNAME]"
git add Jenkinsfile html.go main.go
git commit -m "Version 2.0.0"
git push origin new-feature






3)Push a Canary deployment to the production namespace.


==Now Go to the SSH window, run the following command to create a canary branch in the sample-app directory.
git checkout -b canary
==Merge the change from the development branch.
git merge new-feature
==Now Push the canary to the Git server.
git push origin canary






4)Promote the Canary Deployment to production.( need to MERGE and PUSH it to the Git Server.)


===Now Go to the SSH window, run the following commands to merge the canary branch and push it to the Git server.
git checkout master
git merge canary
git push origin master

===In Jenkins, you should see the master pipeline has kicked off.
===You can check the service URL to ensure that all of the traffic is being served by your new version, 2.0.0.
export FRONTEND_SERVICE_IP=$(kubectl get -o \ jsonpath="{.status.loadBalancer.ingress[0].ip}" --namespace=production services gceme-frontend)






